\section{Accumulation}\label{sec:accumulation}

Accumulation may be defined as some function whose arguments are $\mathbf{W}$ and $\delta$ together with selected portions of (at times partially transitioned) state and which yields the posterior service state $\delta'$ together with additional state elements $\iota'$, $\varphi'$ and $\chi'$.

The proposition of accumulation is in fact quite simple: we merely wish to execute the \emph{Accumulate} logic of the service code of each of the services which has at least one work output, passing to it the work outputs and useful contextual information. However, there are three main complications. Firstly, we must define the execution environment of this logic and in particular the host functions available to it. Secondly, we must define the amount of gas to be allowed for each service's execution. Finally, we must determine the nature of transfers within Accumulate which, as we will see, leads to the need for a second entry-point, \emph{on-transfer}.



\subsection{Preimage Integration}

Prior to accumulation, we must first integrate all preimages provided in the lookup extrinsic. The lookup extrinsic is a sequence of pairs of service indices and data. These pairs must be ordered and without duplicates (equation \ref{eq:preimagesareordered} requires this). The data must have been solicited by a service but not yet be provided. Formally:
\begin{align}
  \xtpreimages &\in \lseq \ltuple\N_S\ts\Y\rtuple \rseq \\
  \label{eq:preimagesareordered}\xtpreimages &= \orderuniqby{i}{i \in \xtpreimages} \\
  \forall \tup{s\ts\mathbf{p}} \in \xtpreimages &: \left\{\ 
    \begin{aligned}
      &\keys{\delta[s]_\mathbf{p}}\ \not\ni\ \mathcal{H}(\mathbf{p})\ ,\\
      &\delta[s]_\mathbf{l}[\tup{\mathcal{H}(\mathbf{p}), |\mathbf{p}|}]\ =\ []
    \end{aligned}
  \right.
\end{align}

We define $\delta^\dagger$ as the state after the integration of the preimages:
\begin{align}
    \delta^\dagger = \delta \text{ ex. } \forall \tup{s\ts\mathbf{p}} \in \xtpreimages : \left\{\,\begin{aligned}
      \quad\delta^\dagger[s]_\mathbf{p}[\mathcal{H}(\mathbf{p})] &= \mathbf{p} \\
      \delta^\dagger[s]_\mathbf{l}[\mathcal{H}(\mathbf{p}), |\mathbf{p}|] &= [\tau']
    \end{aligned}\right.\!\!
\end{align}





\subsection{History and Queuing}

Accumulation of a work-package/work-report is deferred in the case that it has a not-yet-fulfilled dependency and is cancelled entirely in the case of an invalid dependency. Dependencies are specified as work-package hashes and in order to know which work-packages have been accumulated already, we maintain a history of what has been accumulated. This history, $\accumulated$, is sufficiently large for an epoch worth of work-reports. For all such reports, we also retain their segment-root in order that we may validate any guarantor-proscribed segment-roots in work-reports prior to accumulation. Formally:
\begin{align}
  \accumulated &\in \seq{\dict{\H}{\H}}_\mathsf{E} \\
  \wideparen{\accumulated} &\equiv \{ x \mid x \in \accumulated \}
\end{align}

We also maintain knowledge of available but not-yet-accumulated work-reports in the state item $\ready$. Each of these have been available for at most one epoch but have or had unfulfilled dependencies. Alongside the work-report itself, we retain its unaccumulated dependencies, a set of work-package hashes. Formally:
\begin{align}
  \ready &\in \seq{\seq{(\mathbb{W}, \{\H\})}}_\mathsf{E}
\end{align}

The newly available work-reports, $\mathbf{W}$, are partitioned into two sequences based on the condition of having zero prerequisite work-reports. Those meeting the condition, $\mathbf{W}^!$, are accumulated immediately. Those not, $\mathbf{W}^Q$, are for queued execution. Formally:
\begin{align}
  \mathbf{W}^! &\equiv [ w \mid w \orderedin \mathbf{W}, (w_x)_p = \none ] \\
  \mathbf{W}^Q &\equiv E([ w \mid w \orderedin \mathbf{W}, (w_x)_p \ne \none ], \wideparen{\accumulated}) \\
  \accumulated'_{\mathsf{E} - 1} &= M(\mathbf{D}) \\
  \using s &= \min(\tau' - \tau, \mathsf{E}) \\
  \forall i &\in \N_\mathsf{E} : \ready'^\circlearrowleft_{m - i} = \begin{cases}
    E(\mathbf{W}^Q, \mathbf{D}) &\when i = 0 \\
    [] &\when 1 \le i < s \\
    \ready^\circlearrowleft_{m - i} &\when i \ge s
  \end{cases} \\
  \forall i &\in \N_\mathsf{E - 1}: \accumulated'_{i} \equiv \accumulated_{i + 1}
\end{align}

We must define the various dependent functions. Firstly, the accumulation priority queue function $Q$, which is given our two state items and will provide the sequence of work-reports which are accumulatable, on the provision that all work-reports in the sequence prior are themselves accumulated. Secondly, the mapping function $M$ which builds a dictionary of work-package hashes to segment-roots from a set of work-reports. Formally:
\begin{align}
  &Q\colon\left\{\begin{aligned}
    &(\seq{(\mathbb{W}, \{\H\})}, \dict{\H}{\H}) \to \seq{\mathbb{W}} \\
    &(\mathbf{r}, \mathbf{a}) \mapsto \begin{cases}
      [] &\when w = \none \\
      \mathbf{g} \frown Q(E(\mathbf{r}, \mathbf{g}), \mathbf{a} \cup M(\mathbf{g}))\!\!\!\! &\otherwise \\
      \where \mathbf{g} = [w \mid (w, \{\}) \orderedin \mathbf{r}]\!\!\!\!\!\!\!\!\! &
    \end{cases}\!\!\!\!
  \end{aligned}\right.\\
  &M\colon\left\{\begin{aligned}
    \{\mathbb{W}\} &\to \dict{\H}{\H}\\
    \mathbf{w} &\mapsto \{ ((w_s)_h \mapsto (w_s)_e) \mid w \in \mathbf{w} \}
  \end{aligned}\right.
\end{align}

Next, the queue-editing function $E$, which is essentially a mutator function for items such as those of $\ready$, parameterized by a dictionary similar to the items in $\accumulated$. It is used to update queues of work-reports when some of them are accumulated. Functionally, it removes all entries whose work-report's hash is in the parameter's keys, removes any dependencies which appear in said set and, crucially, removes any entries whose segment-root correspondences diverge from those in the dictionary. Formally:
\begin{equation}
  E\colon\left\{\begin{aligned}
      &(\seq{(\mathbb{W}, \{\H\})}, \dict{\H}{\H}) \to \seq{(\mathbb{W}, \{\H\})} \\
    &(\mathbf{r}, \mathbf{x}) \mapsto \left[
      (w, \mathbf{d} \setminus \keys{\mathbf{x}})
      \,\middle\vert\,
      \left\{\,\begin{aligned}
        &(w, \mathbf{d}) \orderedin \mathbf{r} ,\\
        &\mathcal{H}(\se(w)) \not\in \keys{\mathbf{x}},\\
        &\mathbf{x} \cup w_\mathbf{d} = w_\mathbf{d} \cup \mathbf{x}
      \end{aligned}\right.
      \right]
  \end{aligned}\right.
\end{equation}

We may now define the sequence of accumulatable work-reports in this block as $\mathbf{W}^*$:
\begin{equation}
  \mathbf{W}^* \equiv \mathbf{W}^! \frown Q(\wideparen{\ready_{m\dots}} \concat \wideparen{\ready_{\dots m}} \concat \mathbf{W}^Q, \wideparen{\accumulated})
\end{equation}

We work with a limited amount of gas per block and therefore may not be able to process all items in $\mathbf{W}^*$ in a single block. As many as possible are processed while staying within our gas limit and we aggregate the set of accumulated work-reports as $\mathbf{D}$.


TODO: Specify a single iteration of the accumulation-loop.

TODO: Specify the accumulation loop.

TODO: Consider reserving some cores for processing the queue.

\subsection{Recursive Accumulation}

\begin{align}
  C &\equiv \left(\begin{aligned}
    \dict{\N_S}{\mathbb{A}} \,,\;
    \seq{\mathbb{K}}_\mathsf{V} \,,\;
    \seq{\seq{\H}_\mathsf{Q}}_\mathsf{C} \,,\\
    (\N_S,\N_S,\N_S,\dict{\N_S}{\N_G})
  \end{aligned}\right)\\
  B &\equiv \{(\N_S, \H)\}
\end{align}

\begin{equation}
  Z\colon\left\{\begin{aligned}
    &(\N_G, \seq{\mathbb{W}}, C) \to (\seq{\mathbb{W}}, C, B) \\
    &(g, \mathbf{w}, \mathbf{o}) \mapsto \begin{cases}
      ([], \mathbf{o}, \{\}) &
        \when i = 0 \\
      (\mathbf{w}', \mathbf{o}', \mathbf{b}^* \cup \mathbf{b}) &
        \otherwise \\
    \end{cases} \\
    &\quad\where i = \max(\N_{|\mathbf{w}| + 1}): \sum_{w \in \mathbf{w}_{\dots i}}\sum_{r \in w_\mathbf{r}}(r_g) \le g \\
    &\quad\also (g^*, \mathbf{o}^*, \mathbf{b}^*) = A(\mathbf{o}, \mathbf{w}_{\dots i}) \\
    &\quad\also (\mathbf{w}', \mathbf{o}', \mathbf{b}) = Z(g - u, \mathbf{w}_{i\dots}, \mathbf{o}')
  \end{aligned}\right.
\end{equation}



\subsection{Work Report Selection}

We select a series of work reports from 

\subsection{Gas Accounting}

We define $\mathbf{S}$, the set of all services which will be accumulated in this block; this is all services which have at least one work output within $\mathbf{W}$, together with the privileged services, $\chi_\mathbf{g}$. Formally:
\begin{align}\label{eq:servicestoaccumulate}
  \mathbf{S} \equiv \{ \mathbf{r}_s \mid w \in \mathbf{W}, \mathbf{r} \in w_\mathbf{r} \} \cup \keys{\chi_\mathbf{g}}
\end{align}

We calculate the gas attributable for each service as the sum of each of the service's work outputs' share of their report's elective accumulation gas together with the subtotal of minimum gas requirements:
\begin{equation}
  G\colon\left\{\;\begin{aligned}
    \N_S &\to \N_G \\
    \displaystyle s &\mapsto \subifnone((\chi_\mathbf{g})_s, 0) + \sum_{w \in \mathbf{W}}\sum_{\mathbf{r} \in w_\mathbf{r} , \mathbf{r}_s = s}{\mathbf{r}_g}
  \end{aligned}\right.
\end{equation}

\subsection{Wrangling}

We finally define the results which will be given as an operand into the accumulate function for each service in $\mathbf{S}$. This is a sequence of operand tuples $\mathbb{O}$, one sequence for each service in $\mathbf{S}$. Each sequence contains one element per work output (or error) to be accumulated for that service, together with said work output's payload hash, package hash and authorization output. The tuples are sequenced in the same order as they appear in $\mathbf{W}$. Formally:
\begin{align}
  \mathbb{O} \equiv \ltuple\isa{o}{\Y \cup \mathbb{J}}\ts\isa{l}{\H}\ts\isa{k}{\H}\ts\isa{a}{\Y}\rtuple
\end{align}
\begin{align}
  M\colon\left\{\ \begin{aligned}
    \N_S &\to \lseq\mathbb{O}\rseq \\
    \displaystyle s &\mapsto \left[ \ltup\begin{alignedat}{3}
        \is{o&}{\mathbf{r}_o}\ts\is{&l&}{\mathbf{r}_p}\ts\\
        \is{a&}{w_o}\ts\is{&k&}{(w_s)_h}
    \end{alignedat}\rtup
      \,\middle\vert\ 
    \begin{aligned}
      w &\in \mathbf{W},\\
      \mathbf{r} &\in w_\mathbf{r},\\
      \mathbf{r}_s &= s
    \end{aligned}\ \right]
  \end{aligned}\right.
\end{align}

\subsection{Invocation}

Within this section, we define $A$, the function which conducts the accumulation of a single service. Formally speaking, $A$ assumes omnipresence of timeslot $\mathbf{H}_t$ and some prior state components $\delta^\dagger$, $\nu$, $\mathbf{W}_\mathbf{d}$, and takes as specific arguments the service index $s \in \mathbf{S}$ (from which it may derive the wrangled results $M(s)$ and gas limit $G(s)$) and yields values for $\delta^\ddagger[s]$ and staging assignments into $\varphi$, $\iota$ together with a series of lookup solicitations/forgets, a series of deferred transfers and $\mathbf{C}$ mapping from service index to \textsc{Beefy} commitment hashes.

We first denote the set of deferred transfers as $\mathbb{T}$, noting that a transfer includes a memo component $m$ of 64 octets, together with the service index of the sender $s$, the service index of the receiver $d$, the amount of tokens to be transferred $a$ and the gas limit $g$ for the transfer. Formally:
\begin{align}
  \mathbb{T} \equiv \ltuple\isa{s}{\N_S}\ts\isa{d}{\N_S}\ts\isa{a}{\N_B}\ts\isa{m}{\Y_{\mathsf{M}}}\ts\isa{g}{\N_G}\rtuple
\end{align}

We may then define $A$, the mapping from the index of accumulated services to the various components in terms of which we will be imminently defining our posterior state:
\begin{align}
  A \colon \left\{\begin{aligned}
      \N_S &\to \ltuple\ \begin{aligned}
        \isa{\mathbf{s}&}{\mathbb{A}\bm{?}}\ts\quad
        \isa{\mathbf{v}}{\seq{\mathbb{K}}_\mathsf{V}}\ts\quad
        \isa{\mathbf{t}}{\seq{\mathbb{T}}}\ts\quad
        \isa{r}{\H\bm{?}}\ts\\
        \isa{\mathbf{c}&}{\lseq\lseq\H\rseq_\mathsf{Q}\rseq_\mathsf{C}}\ts\qquad
        \isa{\mathbf{n}}{\dict{\N_S}{\mathbb{A}}}\ts\\
        \isa{p&}{\tuple{\isa{m}{\N_S}, \isa{a}{\N_S}, \isa{v}{\N_S}, \isa{\mathbf{g}}{\dict{\N_S}{\N_G}}}}\\
      \end{aligned}\rtuple \\
      s &\mapsto \Psi_A(\delta^\dagger, s, G(s), M(s))
    \end{aligned}\right.
\end{align}

As can be seen plainly, our accumulation mapping $A$ combines portions of the prior state into arguments for a virtual-machine invocation. Specifically the service accounts $\delta^\dagger$ together with the index of the service in question $s$ and its gas limit and wrangled refine-results $M(s)$ are arranged to create the arguments for $\Psi_A$, itself using a virtual-machine invocation as defined in appendix \ref{sec:accumulateinvocation}. Note that the gas limit is the sum of the regular gas $G(s)$ together with any privileged gas it receives $(\chi_\mathbf{g})_s$.

The \textsc{Beefy} commitment map is a function mapping all accumulated services to their accumulation result (the $r$ component of the result of $A$). This is utilized in determining the accumulation-result tree root for the present block, useful for the \textsc{Beefy} protocol:
\begin{equation}\label{eq:beefycommitment}
  \mathbf{C} \equiv \{ (s, A(s)_r) \mid s \in \mathbf{S}, A(s)_r \ne \none \}
\end{equation}

Given our mapping $A$, which may be calculated exhaustively from the \textsc{vm} invocations of each accumulated service $\mathbf{S}$, we may define the posterior state $\delta'$, $\chi'$, $\varphi'$ and $\iota'$ as the result of integrating $A$ into our state.

\subsubsection{Privileged Transitions}
The staging core assignments, and validator keys and privileged service set are each altered based on the effects of the accumulation of each of the three privileged services:
\begin{align}
  \chi' \equiv A(\chi_m)_p \ ,\quad
  \varphi' \equiv A(\chi_a)_\mathbf{c} \ ,\quad
  \iota' \equiv A(\chi_v)_\mathbf{v}
\end{align}

\subsubsection{Service Account Transitions}
Finally, we integrate all changes to the service accounts into state.

We note that all newly added service indices, defined as $\keys{A(s)_\mathbf{n}}$ for any accumulated service $s$, must not conflict with the indices of existing services or newly added services. This should never happen, since new indices are explicitly selected to avoid such conflicts, but in the unlikely event it happens, the block would be invalid. Formally:
\begin{equation}
  \begin{aligned}
  \forall s \in \mathbf{S} :\ &\keys{A(s)_\mathbf{n}} \cap \keys{\delta^\dagger} = \none, \\
  \forall t \in \mathbf{S} \setminus \{s\} :\ &\keys{A(s)_\mathbf{n}} \cap \keys{A(t)_\mathbf{n}} = \none
\end{aligned}
\end{equation}

We first define $\delta^\ddagger$, an intermediate state after main accumulation but before the transfers have been credited and handled:
\begin{equation}\begin{aligned}
  \keys{\delta^\ddagger} &\equiv \left ( \keys{\delta^\dagger} \cup \bigcup_{s \in \mathbf{S}} \keys{A(s)_\mathbf{n}} \right ) \setminus \left\{s\ \middle\vert\ \begin{aligned}s &\in \mathbf{S},\\s_\mathbf{s} &= \none\end{aligned}\ \right\}\!\!\\
  \delta^\ddagger[s] &\equiv \begin{cases}
    A(s)_\mathbf{s} &\when s \in \mathbf{S}\\
    A(t)_\mathbf{n}[s] &\when \exists! t : t \in \mathbf{S}, s \in \keys{A(t)_\mathbf{n}} \\
    \delta^\dagger[s] &\otherwise
  \end{cases}
\end{aligned}\end{equation}

We denote $R(s)$ the sequence of transfers received by a given service of index $s$, in order of them being sent from services of ascending index. (If some service $s$ received no transfers or simply does not exist then $R(s)$ would be validly defined as the empty sequence.) Formally:
\begin{align}
  R\colon \left\{\;\begin{aligned}
    \N_S &\to \lseq\mathbb{T}\rseq \\
    d &\mapsto \left[\,t \mid s \orderedin \mathbf{S},\ t \orderedin A(s)_\mathbf{t},\ t_d = d\,\right]
  \end{aligned}\right.
\end{align}

The posterior state $\delta'$ may then be defined as the intermediate state with all the deferred effects of the transfers applied:
\begin{equation}
  \delta' = \{ s \mapsto \Psi_T(\delta^\ddagger, a, R(a)) \mid (s \mapsto a) \in \delta^\ddagger \}
\end{equation}

Note that $\Psi_T$ is defined in appendix \ref{sec:ontransferinvocation} such that it results in $\delta^\ddagger[d]$, \ie no difference to the account's intermediate state, if $R(d) = []$, \ie said account received no transfers.
